---
title: "Graph"
author: "Cameron Eller"
date: "2024-01-11"
output: html_document
---

```{r}
library(data.table)
library(igraph)
library(qgraph)
library(readr)
library(tidyverse)

# load in all of the donations data
donations = read_csv("../../large_contributions_and_scores.csv", n_max = 10000) #n_max if you don't want to explode

print(nrow(donations))

# individual donations split vs pacs donations split
individual_donations = donations %>%
  filter(pac_or_individual == 'i')
pac_donations = donations %>%
  filter(pac_or_individual == 'p')

print(nrow(individual_donations))
print(nrow(pac_donations))

```

Group-by Mutate:
```{r}
test_df <- pac_donations |>
  group_by(donor_name, candidate_name) |>
  mutate(amount = sum(amount)) |> #instead of donation_total
  select(donor_name, candidate_name, candidate_party, score, lifetime_score, name, amount) |> #removed donation_total, add amount
  ungroup()

test_df <- unique(test_df)

test_df

```

```{r}
#------------------------------------------------------
# create the edge list of individual or pac donors

#edge_list <- individual_donations %>%
#  select(donor_name, candidate_name, amount)

#edge_list <- pac_donations %>%
#  select(donor_name, candidate_name, amount)

edge_list <- test_df |>
  select(donor_name, candidate_name, amount)

#-------------------------------------------------------

# using the edge list create the first graph (not directed)
g <- graph_from_data_frame(d=edge_list, directed=FALSE)

# change the graph type to bipartite
V(g)$type <- bipartite_mapping(g)$type


donor_candidate_amount <- edge_list %>%
  group_by(donor_name, candidate_name) %>%
  summarize(total_amount = sum(amount))


candidate_pairs <- donor_candidate_amount %>%
  full_join(donor_candidate_amount, by="donor_name") %>%
  filter(candidate_name.x != candidate_name.y) %>%
  group_by(candidate_name.x, candidate_name.y) %>%
  summarize(weight = sum(total_amount.x + total_amount.y))

candidate_projection <- bipartite_projection(g, which=TRUE)
V(candidate_projection)$name <- V(g)[V(g)$type == TRUE]$name

#--------------------------------------------------------------
#code that works
E(candidate_projection)$weight <- 0
for (i in 1:nrow(candidate_pairs)) {
  pair <- candidate_pairs[i, ]
  edge <- get.edge.ids(candidate_projection, 
                       c(pair$candidate_name.x, pair$candidate_name.y))
  E(candidate_projection)[edge]$weight <- pair$weight
}
#-------------------------------------------------------
#attempted vectorized code: (revisit)

# Set all edge weights to 0
#E(candidate_projection)$weight <- 0

# Find edge IDs for each pair of candidate names
#edges <- get.edge.ids(candidate_projection, 
#                      cbind(candidate_pairs$candidate_name.x, 
#                            candidate_pairs$candidate_name.y))

# Update edge weights based on the pairs data frame
#E(candidate_projection)[edges]$weight <- candidate_pairs$weight
#----------------------------------------------------------------


wt_communities <- cluster_walktrap(candidate_projection, steps = 1)
membership <- membership(wt_communities)
V(candidate_projection)$community <- membership
str <- strength(candidate_projection, mode="all")


names_of_interest = names(sort(str, decreasing = TRUE)[1:5])
#l = layout_with_dh(candidate_projection)
l = layout_with_lgl(candidate_projection)

last_two_words <- function(name) {
  words <- strsplit(name, " ")[[1]]
  if (length(words) >= 2) {
    paste(tail(words, 2), collapse=" ")
  } else {
    name  
  }
}


vertex_indices = match(names_of_interest, V(candidate_projection)$name)
short_labels <- sapply(V(candidate_projection)$name[vertex_indices], last_two_words)
vlabs = rep(NA, vcount(candidate_projection))
vlabs[vertex_indices] <- short_labels


g = max(str)
print(g)
str = str/g



par(mar=c(0,0,0,0))
plot(candidate_projection, 
     vertex.color=V(candidate_projection)$community,
     vertex.label=vlabs, #V(candidate_projection)$name, 
     vertex.size=str*10, 
     vertex.label.cex = 0.5,
     edge.arrow.size=0, 
     edge.curved=0.1, 
     edge.width=0.2,
     layout=l
)



for (i in unique(membership)) {
  cat("Community", i, ":", names(V(candidate_projection))[membership == i], "\n")
}

```

Writing graph to a file:
```{r}
write_graph(candidate_projection, "01-graph.graphml", format = "graphml")
#write_graph(graph, "graph.gml", format = "gml")

```

Reading in a graph from a file:
```{r}
loaded_graph <- read.graph("01-graph.graphml", format = "graphml")

plot(loaded_graph)

#outputted og graph, will likely need to run it through additional code again

```

Creating a communities data frame:
```{r}

# creating an empty dataframe with two columns, community and congresspeople
communities_df <- data.frame(matrix(ncol = 2, nrow = length(unique(membership))))
colnames(communities_df) <- c("community", "congresspeople")

# add all of the communities to the dataframe (currently out of order)
for (i in unique(membership)) {
  communities_df$community[[i]] <- unique(membership)[i]
}

# reorder the communities from first to last
communities_df <- communities_df |>
  arrange(community)

# add off of the people in each community as a single string
for (i in unique(membership)) {
  communities_df$congresspeople[[i]] <- paste(names(V(candidate_projection)[membership == i]), sep="", collapse=", ") 
}

#print(communities_df)

```
